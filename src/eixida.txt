]633;E;for i in `find -name "*.ts"`;bdca99fc-d43f-4f19-916b-a5d9ca3b7790]633;C./index.ts

import { buildServer } from "./app/http/server";
const app = buildServer();
const port = 3000;
app.listen(port, () => console.log(`Escoltant per 127.0.0.1:${port}`));./app/http/routes/product.routes.ts
import { Router } from "express";
import { CreateProductUseCase } from "../../domain/usecases/products/CreateProductUseCase";
import { GetProductByIdUseCase } from "../../domain/usecases/products/GetProductByIdUseCase";
import { GetProductsUseCase } from "../../domain/usecases/products/GetProductsUseCase";
import { ProductRepositoryInMemory } from "../../infrastructure/persistence/inMemory/ProductRepositotyInMemory";
import { ProductController } from "../controllers/product.controller";

// Creem una implementaci√≥ del repositori
const repo = new ProductRepositoryInMemory();

// Creem el Controlador per als usuaris, proporcionant-li
// inst√†ncies dels casos d'√∫s, que al seu temps hem inicialitzat
// amb el repositori (injecci√≥ de depend√®ncies)
const controller = new ProductController(
  new CreateProductUseCase(repo),
  new GetProductsUseCase(repo),
  new GetProductByIdUseCase(repo)
);


const ProductRouter = Router();
// Definim les rutes dins aquest router i enllacem amb les
// funcions corresponents del controlador.
ProductRouter.post("/", controller.create);
ProductRouter.get("/", controller.getAll);
ProductRouter.get("/:id", controller.getById);


// Exportem el router
export default ProductRouter;



/*
import { Router } from "express";
import { ProductController } from "../controllers/product.controller";
import { CreateProductUseCase } from "../../domain/usecases/products/CreateProductUseCase";

// Creem una implementaci√≥ del repositori
const repo = new ProductRepositoryInMemory();

// Creem el Controlador per als usuaris, proporcionant-li
// inst√†ncies dels casos d'√∫s, que al seu temps hem inicialitzat
// amb el repositori (injecci√≥ de depend√®ncies)
const controller = new ProductController(
  new CreateProductUseCase(repo),
  new GetProductsUseCase(repo),
  new GetProductByIdUseCase(repo)
);


const ProductRouter = Router();
// Definim les rutes dins aquest router i enllacem amb les
// funcions corresponents del controlador.
ProductRouter.post("/", controller.create.bind(controller));
ProductRouter.get("/", controller.getAll.bind(controller));
ProductRouter.get("/:id", controller.getById.bind(controller));


// Exportem el router
export default ProductRouter;
*/./app/http/routes/user.routes.ts
import { Router } from "express";

import { UserRepositoryInMemory } from "../../infrastructure/persistence/inMemory/UserRepositotyInMemory";
import { CreateUserUseCase } from "../../domain/usecases/user/CreateUserUseCase";
import { GetUsersUseCase } from "../../domain/usecases/user/GetUsersUseCase";
import { GetUserByIdUseCase } from "../../domain/usecases/user/GetUserByIdUseCase";
import { UserController } from "../controllers/user.controller";

// Creem una implementaci√≥ del repositori
const repo = new UserRepositoryInMemory();

// Creem el Controlador per als usuaris, proporcionant-li
// inst√†ncies dels casos d'√∫s, que al seu temps hem inicialitzat
// amb el repositori (injecci√≥ de depend√®ncies)
const controller = new UserController(
  new CreateUserUseCase(repo),
  new GetUsersUseCase(repo),
  new GetUserByIdUseCase(repo)
);


const userRouter = Router();
// Definim les rutes dins aquest router i enllacem amb les
// funcions corresponents del controlador.
userRouter.post("/", controller.create);
userRouter.get("/", controller.getAll);
userRouter.get("/:id", controller.getById);


// Exportem el router
export default userRouter;
./app/http/controllers/user.controller.ts
import { Request, Response, NextFunction } from "express";
import { CreateUserUseCase } from "../../domain/usecases/user/CreateUserUseCase";
import { GetUsersUseCase } from "../../domain/usecases/user/GetUsersUseCase";
import { GetUserByIdUseCase } from "../../domain/usecases/user/GetUserByIdUseCase";

export class UserController {
    constructor(
        private createUser: CreateUserUseCase,      // Les funcions del controlador seran els casos d'√∫s
        private getUsers: GetUsersUseCase,
        private getUserById: GetUserByIdUseCase
    ) { }

    create=async (req: Request, res: Response, next: NextFunction) => {
        try {
            const result = await this.createUser.execute(req.body);
            res.status(201).json(result);
        } catch (err) { next(err); }
    }

    getAll = async (req: Request, res: Response, next: NextFunction) => {
        try {
            res.json(await this.getUsers.execute());
        } catch (err) { next(err); }
    }

    getById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            let number;
            if (req.params.id == null) number = "-1";
            else number = req.params.id;
            const user = await this.getUserById.execute(Number.parseInt(number));
            if (!user) return res.status(404).json({ message: "User not found" });
            res.json(user);
        } catch (err) { next(err); }
    }
}


/*import { CreateUserUseCase } from "../../domain/usecases/user/CreateUserUseCase";
import { GetUserByIdUseCase } from "../../domain/usecases/user/GetUserByIdUseCase";
import { GetUsersUseCase } from "../../domain/usecases/user/GetUsersUseCase";
import { CreateUserInterface } from "../interfaces/create.user.interface";

// Definim (i exportem) la classe pe al controlador
export class UserController {

    // Constructor
    constructor(
            private createUser: CreateUserUseCase,
    private getUsers: GetUsersUseCase,
    private getUserById: GetUserByIdUseCase
    ){}

    // Definim el m√®tode/middleware create, per a la creaci√≥ d'usuaris.
    // Rebem:
    // - req: de tipus Request, amb la petici√≥
    // - res: de tipus Response, per gestionar la resposta
    public create = (req: Request, res: Response) => {
        // Agafem el nom i l'email del body
        // Amb la interf√≠cie CreateUserInterface indiquem el format esperat en el body
        // (agafem el name i l'email que defineix la interf√≠cie del body)
        const { name, email }: CreateUserInterface = req.body;

        // Comprovem que els valors no siguen nuls
        if (!name || !email) {
            return res.status(400).json({ message: "El nom i l'email s√≥n obligatoris" });
        }

        // Creem el JSON amb el nou usuari
        const newUser = {
            id: (usuaris.length + 1).toString(),
            name,
            email,
            createdAt: new Date().toISOString(),
        };

        // Afegim l'usuari a la llista d'usuaris
        usuaris.push(newUser);

        // I retornem l'usuari creat en la resposta
        res.status(201).json(newUser);
    };


    // M√®tode/Middleware per retornar la llista d'usuaris
    public getAll = (req: Request, res: Response) => {
        res.status(200).json(usuaris);
    };

    // M√®tode/Middleware per retornar les dades d'un usuari concret
    public getById = (req: Request, res: Response) => {
        const id = req.params.id;

        // M√®tode find del vector (funci√≥ fletxa)
        const user = usuaris.find(u => u.id === id);
        // Seria equivalent a:  const user = usuaris.find( function(u){ return u.id === id});


        if (user) { // Si hem trobat l'usuari, el retornem
            res.status(200).json(user);
        } else { // En cas contrari retornem l'error de recurs no trobat
            res.status(404).json({ message: "Usuari no trobat" });
        }
    };
}



*/./app/http/controllers/product.controller.ts
import { Request, Response, NextFunction } from "express";
import { CreateProductUseCase } from "../../domain/usecases/products/CreateProductUseCase";
import { GetProductByIdUseCase } from "../../domain/usecases/products/GetProductByIdUseCase";
import { GetProductsUseCase } from "../../domain/usecases/products/GetProductsUseCase";

export class ProductController {
    constructor(
        private createProduct: CreateProductUseCase,      // Les funcions del controlador seran els casos d'√∫s
        private getProducts: GetProductsUseCase,
        private getProductById: GetProductByIdUseCase
    ) { }

    create=async (req: Request, res: Response, next: NextFunction) => {
        try {
            const result = await this.createProduct.execute(req.body.name, req.body.price, req.body.stock);
            // const result = await this.createProduct.execute(req.body); // Aix√≠ va en users per√≤ no aci...
            res.status(201).json(result);
        } catch (err) { next(err); }
    }

    getAll = async (req: Request, res: Response, next: NextFunction) => {
        try {            
            res.json(await this.getProducts.execute());
        } catch (err) { next(err); }
    }

    getById = async (req: Request, res: Response, next: NextFunction) => {
        try {
            let number;
            if (req.params.id == null) number = "-1";
            else number = req.params.id;
            const product = await this.getProductById.execute(Number.parseInt(number));
            if (!product) return res.status(404).json({ message: "Product not found" });
            res.json(product);
        } catch (err) { next(err); }
    }
}

./app/http/server.ts
import express, { Request, Response, NextFunction } from "express";

// Importem els routers d'usuari i productes
import userRoutes from "./routes/user.routes";
import productRoutes from "./routes/product.routes";

export function buildServer() {
  // Creem l'aplicaci√≥ Express
  const app = express();

  // Utilitzem el middleware express.json per entende 
  // els JSON al cos de les peticions
  app.use(express.json());


  // Configurem l'aplicaci√≥ per usar els routers/miniaplicacions
  // Tindrem un router (miniaplicaci√≥) per als usuaris i altre pe als producte
  app.use("/api/users", userRoutes);
  app.use("/api/products", productRoutes);

  app.use("*", function (req: Request, res: Response, next: NextFunction) {
    res.status(404).json({ message: "Resource not found" });
  })
    ;

  app.use((err: any, req: Request, res: Response, next: NextFunction) => {
    console.error(err); // Log per consola (o logger a futur)

    // Si ja t√© codi d'estat assignat ‚Üí l‚Äôutilitzem
    const status = err.status || 500;

    res.status(status).json({
      error: true,
      message: err.message || "Internal server error",
    });
  });


  return app;
}
./app/http/interfaces/create.user.interface.ts
export interface CreateUserInterface {
  name: string;
  email: string;
}
./app/http/interfaces/create.product.interface.ts
export interface CreateProductInterface {
  name: string;
  price: number;
  stock: number;
}
./app/domain/entities/Product.ts
// Les entitats del domini s√≥n conceptualment un conjunt de propietats essencials.
// La intenci√≥ de la capa de domini √©s definir qu√® √©s un Producte, per√≤ no com funciona.
// Per a aix√≤, amb una Interface que descriga aquestes propietats √©s suficient.
// Ara b√©, en cas que l'entitat necessite d'algun comportament, s√≠ que ser√† necessari fer √∫s de classes.

export interface Product {
  id: number;
  name: string;
  price: number;
  stock: number;
  createdAt: Date;
}./app/domain/entities/User.ts
// Les entitats del domini s√≥n conceptualment un conjunt de propietats essencials.
// La intenci√≥ de la capa de domini √©s definir qu√® √©s un usuari, per√≤ no com funciona.
// Per a aix√≤, amb una Interface que descriga aquestes propietats √©s suficient.
// Ara b√©, en cas que l'entitat necessite d'algun comportament, s√≠ que ser√† necessari fer √∫s de classes.

export interface User {
  id: number;
  name: string;
  email: string;
  createdAt: Date;
}./app/domain/repositories/IUserRepository.ts
import { User } from "../entities/User";

// Definim el comportament del repositori d'usuaris
export interface IUserRepository {
  create(user: Omit<User, "id" | "createdAt">): Promise<User>; //  M√®tode create: Crea un nou usuari. Retorna una promesa amb l'usuari creat
  findById(id: number): Promise<User | null>; // M√®tode per buscar un usuari per id. Retorna una promesa amb l'usuari 
  findAll(): Promise<User[]>;
}./app/domain/repositories/IProductRepository.ts
import { Product } from "../entities/Product";

// Definim el comportament del repositori d'usuaris

export interface IProductRepository {
  create(product: Omit<Product, "id" | "createdAt">): Promise<Product>; //  M√®tode create: Crea un nou producte. Retorna una promesa amb el producte creat
  findById(id: number): Promise<Product | null>;  // M√®tode per buscar un usuari per id. Retorna una promesa amb l'usuari 
  findAll(): Promise<Product[]>;
}./app/domain/usecases/user/GetUserByIdUseCase.ts
import { IUserRepository } from "../../../domain/repositories/IUserRepository";

export class GetUserByIdUseCase {
  constructor(private userRepo: IUserRepository) {}

  async execute(id: number) {
    return this.userRepo.findById(id);
  }
}./app/domain/usecases/user/GetUsersUseCase.ts
import { IUserRepository } from "../../../domain/repositories/IUserRepository";

export class GetUsersUseCase {
  // El cas d'√∫s s'inicialitza amb una interf√≠cie del repositori
  constructor(private userRepo: IUserRepository) {}

  async execute() {
    return this.userRepo.findAll();
  }
}./app/domain/usecases/user/CreateUserUseCase.ts
// Els casos d'√∫s representen la l√≤gica de negoci; qu√® √©s el que pot fer l'aplicaci√≥.
// En l'arquitectura anterior, hem incorporat la l√≤gica de negoci en el propi controlador, 
// per√≤ els controladors el que han de fer √©s controlar les peticions HTTP, no la l√≤gica de 
// l'aplicaci√≥, per aix√≤ s'introdueix aquest capa de casos d'us (que seria pr√†cticament una 
// traducci√≥ literal del diagrama de casos d'√∫s de l'aplicaci√≥!)

  /*// Quan trobem Omit<T, k>
  // El que fa √©s, a partir de ltipus T, elimina les propietats indicades en K
  async execute(data: Omit<User, "id">): Promise<User> {   // Agafa un usuari, li lleva l'ID, i retorna una promesa amb l'usuari
    const user: User = { ...data };
    return this.userRepo.create(user);
  }
}
*/

import { IUserRepository } from "../../repositories/IUserRepository";

interface CreateUserDTO {
  name: string;
  email: string;
}

export class CreateUserUseCase {

  constructor(private userRepository: IUserRepository) {}

  async execute({ name, email }: CreateUserDTO) {

    // (Opcional) **Validacions de domini**
    if (!name || !email) {
      throw new Error("Name and email are required.");
    }

    // (Opcional) Validar que no existeix email duplicat
    const existingUsers = await this.userRepository.findAll();
    if (existingUsers.some(u => u.email === email)) {
      throw new Error("Email already in use.");
    }

    // Deleguem la creaci√≥ (id i createdAt) al repositori
    const user = await this.userRepository.create({ name, email });

    return user;
  }
}



/*import { IUserRepository } from "../../../domain/repositories/IUserRepository";
import { User } from "../../../domain/entities/User";

export class CreateUserUseCase {
  constructor(private userRepository: IUserRepository) {}

  async execute(name: string, email: string): Promise<User> {

    // (Opcional) Validacions de negoci
    if (!email.includes("@")) {
      throw new Error("El correu no √©s v√†lid.");
    }

    // (Opcional) Evitar duplicats
    const existingUsers = await this.userRepository.findAll();
    if (existingUsers.some(u => u.email === email)) {
      throw new Error("Ja existeix un usuari amb aquest correu.");
    }

    // El repositori genera l'id autom√†ticament
    const user = await this.userRepository.create({
      name,
      email
    });

    return user;
  }
}
*/./app/domain/usecases/products/GetProductByIdUseCase.ts
import { IProductRepository } from "../../../domain/repositories/IProductRepository";

export class GetProductByIdUseCase {
  constructor(private ProductRepo: IProductRepository) {}

  async execute(id: number) {
    return this.ProductRepo.findById(id);
  }
}./app/domain/usecases/products/CreateProductUseCase.ts
// Els casos d'√∫s representen la l√≤gica de negoci; qu√® √©s el que pot fer l'aplicaci√≥.
// En l'arquitectura anterior, hem incorporat la l√≤gica de negoci en el propi controlador, 
// per√≤ els controladors el que han de fer √©s controlar les peticions HTTP, no la l√≤gica de 
// l'aplicaci√≥, per aix√≤ s'introdueix aquest capa de casos d'us (que seria pr√†cticament una 
// traducci√≥ literal del diagrama de casos d'√∫s de l'aplicaci√≥!)


import { IProductRepository } from "../../../domain/repositories/IProductRepository";
import { Product } from "../../../domain/entities/Product";

export class CreateProductUseCase {
  constructor(private ProductRepository: IProductRepository) { }

  async execute(name: string, price: number, stock: number): Promise<Product> {


    // El repositori genera l'id autom√†ticament
    const product = await this.ProductRepository.create({
      name,
      price,
      stock,

    });

    return product;
  }
}
./app/domain/usecases/products/GetProductsUseCase.ts
import { IProductRepository } from "../../repositories/IProductRepository";


export class GetProductsUseCase {
  constructor(private userRepo: IProductRepository) {}

  async execute() {
    return this.userRepo.findAll();
  }
}./app/data/dades.ts
let usuaris=[
  {
    "id": 1,
    "name": "Juan P√©rez",
    "email": "juan@example.com",
    "createdAt": "2025-10-23T00:00:00Z"
  },
  {
    "id": 2,
    "name": "Maria L√≥pez",
    "email": "maria@example.com",
    "createdAt": "2025-10-22T00:00:00Z"
  },
  {
    "id": 3,
    "name": "Carlos Garc√≠a",
    "email": "carlos@example.com",
    "createdAt": "2025-10-21T00:00:00Z"
  }
];

let productes=[
  {
    "id": 1,
    "name": "Laptop",
    "price": 999.99,
    "stock": 10,
    "createdAt": "2025-10-23T00:00:00Z"
  },
  {
    "id": 2,
    "name": "Smartphone",
    "price": 499.99,
    "stock": 25,
    "createdAt": "2025-10-22T00:00:00Z"
  },
  {
    "id": 3,
    "name": "Headphones",
    "price": 89.99,
    "stock": 100,
    "createdAt": "2025-10-21T00:00:00Z"
  }
];

export {usuaris, productes};./app/infrastructure/persistence/inMemory/ProductRepositotyInMemory.ts
import { IProductRepository } from "../../../domain/repositories/IProductRepository";
import { Product } from "../../../domain/entities/Product";
import { ProductMapper } from "../../mappers/ProductMapper";
import { ProductRecord } from "./models/ProductRecord";
import { productes } from "../../../data/dades";

export class ProductRepositoryInMemory implements IProductRepository {
  private Products: ProductRecord[] = productes;

  async create(Product: Omit<Product, "id" | "createdAt">): Promise<Product> {
    const nextId = this.Products.length === 0 ? 1 : Math.max(...this.Products.map(u => u.id)) + 1;

    const record: ProductRecord = {
      id: nextId,
      createdAt: new Date().toISOString(),
      ...Product
    };

    this.Products.push(record);

    return ProductMapper.toDomain(record);
  }

  async findById(id: number): Promise<Product | null> {
    const record = this.Products.find(u => u.id === id);
    return record ? ProductMapper.toDomain(record) : null;
  }

  async findAll(): Promise<Product[]> {
    return this.Products.map(ProductMapper.toDomain);
  }
}
./app/infrastructure/persistence/inMemory/models/UserRecord.ts
// Aci definim els models de dades amb qu√® es treballa 
// en esta capa de persist√®ncia (els DAO en altres contextos)

export interface UserRecord {
  id: number;
  name: string;
  email: string;
  createdAt: string; // << guardat com string per exemple (ISO)
}
./app/infrastructure/persistence/inMemory/models/ProductRecord.ts
// Aci definim els models de dades amb qu√® es treballa 
// en esta capa de persist√®ncia (els DAO en altres contextos)

export interface ProductRecord {
  id: number;
  name: string;
  price: number;
  stock: number;
  createdAt: string; // << guardat com string per exemple (ISO)
}
./app/infrastructure/persistence/inMemory/UserRepositotyInMemory.ts
import { IUserRepository } from "../../../domain/repositories/IUserRepository";
import { User } from "../../../domain/entities/User";
import { UserMapper } from "../../mappers/UserMapper";
import { UserRecord } from "./models/UserRecord";
import { usuaris } from "../../../data/dades";

export class UserRepositoryInMemory implements IUserRepository {
  private users: UserRecord[] = usuaris;

  async create(user: Omit<User, "id" | "createdAt">): Promise<User> {
    const nextId = this.users.length === 0 ? 1 : Math.max(...this.users.map(u => u.id)) + 1;

    const record: UserRecord = {
      id: nextId,
      createdAt: new Date().toISOString(),
      ...user
    };

    this.users.push(record);

    return UserMapper.toDomain(record);
  }

  async findById(id: number): Promise<User | null> {
    const record = this.users.find(u => u.id === id);
    return record ? UserMapper.toDomain(record) : null;
  }

  async findAll(): Promise<User[]> {
    return this.users.map(UserMapper.toDomain);
  }
}
./app/infrastructure/mappers/ProductMapper.ts
// Mapper. Mapeja la representaci√≥ de la capa de persist√®ncia a la capa de domini.

import { Product } from "../../domain/entities/Product";
import { ProductRecord } from "../persistence/inMemory/models/ProductRecord";

export class ProductMapper {
    static toDomain(record: ProductRecord): Product {
        return {
            ...record,   // Propagaci√≥ del registre. 
            createdAt: new Date(record.createdAt)
        };
    }

    // Quan trobem Omit<T, k>
    // El que fa √©s, a partir de ltipus T, elimina les propietats indicades en K
    // Omit<Product, "createdAt" | "id">: Vol dir Agafa Product, i lleva-li els par√†metres createdAt i id
    static toRecord(Product: Omit<Product, "createdAt" | "id"> & { createdAt: Date; id: number }): ProductRecord {
        return {
            ...Product,  // propagaci√≥ de l'usuari: Expandeix els elements d'un iterable a lloc on s'esperen arguments o elements
            createdAt: Product.createdAt.toISOString()
        };
    }
}
./app/infrastructure/mappers/UserMapper.ts
// Mapper. Mapeja la representaci√≥ de la capa de persist√®ncia a la capa de domini.

import { User } from "../../domain/entities/User";
import { UserRecord } from "../persistence/inMemory/models/UserRecord";

export class UserMapper {
    static toDomain(record: UserRecord): User {
        return {
            ...record,   // Propagaci√≥ del registre. 
            createdAt: new Date(record.createdAt)
        };
    }

    // Quan trobem Omit<T, k>
    // El que fa √©s, a partir de ltipus T, elimina les propietats indicades en K
    // Omit<User, "createdAt" | "id">: Vol dir Agafa User, i lleva-li els par√†metres createdAt i id
    static toRecord(user: Omit<User, "createdAt" | "id"> & { createdAt: Date; id: number }): UserRecord {
        return {
            ...user,  // propagaci√≥ de l'usuari: Expandeix els elements d'un iterable a lloc on s'esperen arguments o elements
            createdAt: user.createdAt.toISOString()
        };
    }
}
